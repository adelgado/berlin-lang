def(= fn!(a b ~{invoke-operator("===" a b)}))

def(or fn!(a b ~{invoke-operator("||" a b)}))

def(zero? fn(a ~{=(a 0)}))

def(count fn!(coll ~{.-length(coll)}))

def(empty? fn(coll ~{
  if(=(coll null)
    ~{true}
    ~{zero?(count(coll))})}))

def(first fn!(coll ~{.-0(coll)}))

def(ffirst fn(coll ~{first(first(coll))}))

def(second fn!(coll ~{.-1(coll)}))

def(third fn!(coll ~{.-2(coll)}))

def(last fn(coll ~{
  if(next(coll)
    ~{last(rest(coll))}
    ~{first(coll)})}))

def(butlast fn(coll ~{
  if(next(coll)
    ~{cons(first(coll) butlast(rest(coll)))}
    ~{null})}))

def(rest fn(coll ~{
  if(=(coll null)
    ~{[]}
    ~{.slice(coll 1)})}))

def(next fn(coll ~{
  let([r rest(coll)] ~{
    if(empty?(r) ~{null} ~{r})})}))

def(cons fn(el coll ~{
  if(=(coll null)
    ~{[el]}
    ~{[el ...coll]})}))

def(string? fn(a ~{=(invoke-operator("typeof" a) "string")}))
def(number? fn(a ~{=(invoke-operator("typeof" a) "number")}))
def(keyword? fn(a ~{=(invoke-operator("typeof" a) "symbol")}))
def(boolean? fn(a ~{=(invoke-operator("typeof" a) "boolean")}))
def(null? fn(a ~{=(a null)}))
def(set? fn(a ~{invoke-operator("instanceof" a Set)}))
def(map? fn(a ~{invoke-operator("instanceof" a Map)}))
def(array? fn(a ~{.isArray(Array a)}))

def(arr fn(a ~{
  if(=(a null)
    ~{[]}
    ~{if(string?(a)
      ~{.split(a "")}
      ~{if(or(set?(a) map?(a))
        ~{.from(Array a)}
        ~{if(array?(a)
          ~{a}
          ~{invoke-operator("throw" "Given item not iterable")})})})})}))

def(log fn(...args ~{.log(console ...args)}))

def(+ fn!(a b ~{invoke-operator("+" a b)}))

def(- fn!(a b ~{invoke-operator("-" a b)}))

def(* fn!(a b ~{invoke-operator("*" a b)}))

def(/ fn!(a b ~{invoke-operator("/" a b)}))

def(% fn!(a b ~{invoke-operator("%" a b)}))

def(inc fn(a ~{+(a 1)}))

def(dec fn(a ~{-(a 1)}))

def(true? fn(a ~{=(a true)}))

def(false? fn(a ~{=(a false)}))

def(truthy? fn(a ~{
  if(=(a false)
    ~{false}
    ~{if(=(a null)
        ~{false}
        ~{if(=(a undefined)
            ~{false}
            ~{true})})})}))

def(falsey? fn(a ~{if(truthy?(a)
                    ~{false}
                    ~{true})}))

def(not falsey?)

def(even? fn(a ~{zero?(%(a 2))}))

def(odd? fn(a ~{not(even?(a))})) ; TODO: Use comp instead

def(apply fn(f ...args ~{
  let([additionalArgs arr(butlast(args))
       argsArray last(args)
       args [...additionalArgs ...argsArray]]
    ~{f.apply(null args)})}))

def(map fn(f coll ~{
  if(empty?(coll)
    ~{[]}
    ~{let([el first(coll)] ~{
      cons(f(el) map(f rest(coll)))})})}))

def(filter fn(f coll ~{
  if(empty?(coll)
    ~{[]}
    ~{let([el first(coll)]
      ~{if(f(el)
        ~{cons(el filter(f rest(coll)))}
        ~{filter(f rest(coll))})})})}))

; Takes either [f coll] or [f val coll]
def(reduce fn(...args ~{
  if(=(count(args) 2)
    ~{reduce(first(args) first(second(args)) rest(second(args)))}
    ~{let([f first(args)
           val second(args)
           coll third(args)]
      ~{if(empty?(coll)
        ~{val}
        ~{let([item first(coll)
               result f(val item)]
          ~{reduce(f result rest(coll))})})})})}))

def(comp fn(...args ~{
  let([val last(args)
       fns butlast(args)]
    ~{reduce(fn(acc curr ~{
              curr(acc)}) val fns)})}))

; Export the above functions
def(exp Object.())
set(exp "=" =)
set(exp "zero?" zero?)
set(exp "count" count)
set(exp "empty?" empty?)
set(exp "first" first)
set(exp "ffirst" ffirst)
set(exp "second" second)
set(exp "third" third)
set(exp "last" last)
set(exp "butlast" butlast)
set(exp "rest" rest)
set(exp "next" next)
set(exp "cons" cons)
set(exp "string?" string?)
set(exp "number?" number?)
set(exp "keyword?" keyword?)
set(exp "boolean?" boolean?)
set(exp "null?" null?)
set(exp "set?" set?)
set(exp "map?" map?)
set(exp "array?" array?)
set(exp "arr" arr)
set(exp "log" log)
set(exp "+" +)
set(exp "-" -)
set(exp "*" *)
set(exp "/" /)
set(exp "%" %)
set(exp "inc" inc)
set(exp "dec" dec)
set(exp "true?" true?)
set(exp "false?" false?)
set(exp "truthy?" truthy?)
set(exp "falsey?" falsey?)
set(exp "not" not)
set(exp "even?" even?)
set(exp "odd?" odd?)
set(exp "apply" apply)
set(exp "map" map)
set(exp "filter" filter)
set(exp "reduce" reduce)
set(exp "comp" comp)

set(module "exports" exp)
